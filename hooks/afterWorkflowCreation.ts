import type { Node, Edge } from '../types';
import type { AiClient } from '../../../ai/types';
import type { WorkflowPRD } from '../../../ai/prdEngine';
import { generateWorkflowPRD } from '../../../ai/prdEngine';
import { extractSemanticWorkflowModel } from '../utils/extractSemanticWorkflowModel';
import { loadWorkflowPRD, saveWorkflowPRD, saveWorkflowPRDVersion } from '../utils/prdStorage';

export type WorkflowCreationSource = 'kiteai' | 'figma' | 'image' | 'import' | 'template';

export interface AfterWorkflowCreationParams {
  projectId: string;
  workflows: Array<{
    workflowId: string;
    workflowName: string;
    nodes: Node[];
    edges: Edge[];
  }>;
  source: WorkflowCreationSource;
  generatePRD: boolean;
  aiClient: AiClient;
  onPRDGenerated?: (workflowId: string, prd: WorkflowPRD) => void;
  onProjectDetailsGenerated?: (details: ProjectDetails) => void;
  onError?: (error: Error, context: string) => void;
}

export interface ProjectDetails {
  title: string;
  overview: string;
  primaryUser?: string;
  problemStatement?: string;
  successCriteria?: string[];
  generatedBy: 'ai';
  generatedAt: number;
}

export interface AfterWorkflowCreationResult {
  workflowPRDs: Map<string, WorkflowPRD>;
  projectDetails?: ProjectDetails;
  errors: Array<{ context: string; error: Error }>;
}

export async function afterWorkflowCreation(
  params: AfterWorkflowCreationParams
): Promise<AfterWorkflowCreationResult> {
  const { 
    projectId, 
    workflows, 
    source, 
    generatePRD, 
    aiClient,
    onPRDGenerated,
    onProjectDetailsGenerated,
    onError 
  } = params;

  const result: AfterWorkflowCreationResult = {
    workflowPRDs: new Map(),
    errors: []
  };

  console.log(`[afterWorkflowCreation] Starting post-creation tasks for project ${projectId}`);
  console.log(`[afterWorkflowCreation] Source: ${source}, generatePRD: ${generatePRD}, workflows: ${workflows.length}`);

  if (!generatePRD) {
    console.log('[afterWorkflowCreation] PRD generation disabled, skipping');
    return result;
  }

  for (const workflow of workflows) {
    const { workflowId, workflowName, nodes, edges } = workflow;

    try {
      const existingPRD = loadWorkflowPRD(projectId, workflowId);
      
      if (existingPRD) {
        console.log(`[afterWorkflowCreation] PRD already exists for workflow ${workflowId}, skipping`);
        result.workflowPRDs.set(workflowId, existingPRD);
        continue;
      }

      if (nodes.length === 0) {
        console.log(`[afterWorkflowCreation] No nodes in workflow ${workflowId}, skipping PRD generation`);
        continue;
      }

      console.log(`[afterWorkflowCreation] Generating PRD for workflow ${workflowId} (${workflowName})`);
      
      const semanticModel = extractSemanticWorkflowModel(workflowId, workflowName, nodes, edges);
      const prd = await generateWorkflowPRD(aiClient, semanticModel);
      
      prd.autoGenerated = true;
      prd.draft = true;

      saveWorkflowPRD(projectId, workflowId, prd);
      saveWorkflowPRDVersion(projectId, workflowId, prd, 'ai-generate');

      console.log(`[afterWorkflowCreation] PRD saved for workflow ${workflowId} with key: prd-workflow-${projectId}-${workflowId}`);
      
      result.workflowPRDs.set(workflowId, prd);
      onPRDGenerated?.(workflowId, prd);

    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      console.error(`[afterWorkflowCreation] Failed to generate PRD for workflow ${workflowId}:`, err);
      result.errors.push({ context: `workflow-prd-${workflowId}`, error: err });
      onError?.(err, `PRD generation for workflow ${workflowId}`);
    }
  }

  if (result.workflowPRDs.size > 0) {
    try {
      const projectDetails = await generateProjectDetails(
        projectId,
        workflows,
        Array.from(result.workflowPRDs.values()),
        aiClient
      );
      
      if (projectDetails) {
        result.projectDetails = projectDetails;
        onProjectDetailsGenerated?.(projectDetails);
        console.log(`[afterWorkflowCreation] Project details generated for project ${projectId}`);
      }
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      console.error('[afterWorkflowCreation] Failed to generate project details:', err);
      result.errors.push({ context: 'project-details', error: err });
      onError?.(err, 'Project details generation');
    }
  }

  console.log(`[afterWorkflowCreation] Completed. PRDs: ${result.workflowPRDs.size}, Errors: ${result.errors.length}`);
  return result;
}

async function generateProjectDetails(
  projectId: string,
  workflows: Array<{ workflowId: string; workflowName: string; nodes: Node[]; edges: Edge[] }>,
  workflowPRDs: WorkflowPRD[],
  aiClient: AiClient
): Promise<ProjectDetails | null> {
  if (workflows.length === 0) return null;

  const workflowSummaries = workflows.map(w => {
    const prd = workflowPRDs.find(p => p.workflowId === w.workflowId);
    const overview = prd?.sections.find(s => s.id === 'overview')?.content || '';
    return `- ${w.workflowName}: ${w.nodes.length} steps. ${overview.slice(0, 200)}`;
  }).join('\n');

  const prompt = `Based on these workflow(s), generate project details:

Workflows:
${workflowSummaries}

Return ONLY valid JSON:
{
  "title": "concise project title (3-5 words)",
  "overview": "one paragraph describing what this project does",
  "primaryUser": "who is the main user/customer",
  "problemStatement": "what problem does this solve",
  "successCriteria": ["measurable outcome 1", "measurable outcome 2"]
}`;

  try {
    const response = await aiClient.chat({
      messages: [
        { role: 'system', content: 'You are a product manager creating project documentation. Be concise and specific. Output only valid JSON.' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.3,
      maxTokens: 1000
    });

    let cleanedResponse = response.text
      .replace(/^```json\s?|```$/g, '')
      .replace(/^[^{]*/, '')
      .trim();
    
    const lastBraceIndex = cleanedResponse.lastIndexOf('}');
    if (lastBraceIndex !== -1) {
      cleanedResponse = cleanedResponse.substring(0, lastBraceIndex + 1);
    }

    const parsed = JSON.parse(cleanedResponse);
    
    return {
      title: parsed.title || 'Untitled Project',
      overview: parsed.overview || '',
      primaryUser: parsed.primaryUser,
      problemStatement: parsed.problemStatement,
      successCriteria: parsed.successCriteria,
      generatedBy: 'ai',
      generatedAt: Date.now()
    };
  } catch (error) {
    console.error('[generateProjectDetails] Failed to parse AI response:', error);
    return null;
  }
}
